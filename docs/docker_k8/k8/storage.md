# Storage Concepts

## Introduction of Docker Storage
Docker stores data on the local file system, it creates this directory structures at /var/lib/docker, where it has all the folders and directories called (aufs, containers, image, volumes ). this is place where it stores data by default.

All files related to containers are stored under the containers directory and the files related to images are stored under the image directory. Any volumes created by the Docker containers are created under the volumes directory.

### Layered Architecture
When docker builds images, it builds these in a layered architecture. Each line of instruction in the Docker file creates a new layer in the Docker image with just the changes from the previous layer.

Advantage of layered architecture:
When image builds, docker is not going to build first three layers instead of it reuses the same three layers it built for the first application from the cache. This way, Docker builds images faster and efficiently saves disk spaces. Once the build is complete, you cannot modify the contents of these layers and so they are read-only and you can only modify them by initiating a new build.

When you run a container based off of this image, using the Docker run command, Docker creates a container based off of these layers and creates a new writeable layer on top of the image layer. The writeable layer is used to store data created by the container such as log files written by the applications, any temporary files generated by the container.

Examples:

- Let's take an example of our application code. Since we bake our code into the image, the code is part of the image and as such, its read-only. After running a container, what if I wish to modify the source code.
- Yes, I can still modify this file, but before I saved the modified file, Docker automatically creates a copy of the file in the read-write layer and I will then be modifying a different version of the file in the read-write layer. All future modifications will be done on this copy of the file in the read-write layer. This is called *copy-on-right* mechanism.
- The Image layer being a read-only just means that the files in these layers will not be modified in the image itself. So, the image will remain the same all the time until you rebuild the image using the Docker build command. If container destroyed then all of the data that was stored in the container layer also gets deleted.

Container run time engine:
Kubernetes used Docker alone as the container runtime engine, and all the code to work with Docker was embedded within the Kubernetes source code. The Container Runtime Interface is a standard that defines how an orchestration solution like Kubernetes would communicate with container runtimes like Docker

## Persistent Volume
In the large environment, with a lot of users deploying a lot of pods, the users would have to configure storage every time for each Pod.

A Persistent Volume is a cluster-wide pool of storage volumes configured by an administrator to be used by users deploying application on the cluster. The users can now select storage from this pool using Persistent Volume Claims.

```
kind: PersistentVolume
apiVersion: v1
metadata:
  name: pv-vol1
spec:
  accessModes: [ "ReadWriteOnce" ]
  capacity:
   storage: 1Gi
  hostPath:
   path: /tmp/data
```

```
kubectl create -f pv.yaml
kubectl get pv
kubectl delete pv pv-vol1
```

## Persistent Volume Claim
Now we will create a Persistent Volume Claim to make the storage available to the node. Volumes and Persistent Volume Claim are two separate objects in the Kubernetes namespace.
*Once the Persistent Volume Claim created, Kubernetes binds the Persistent Volumes to claim based on the request and properties set on the volume.*

```
kind: PersistentVolumeClaim
apiVersion: v1
metadata:
  name: myclaim1
spec:
  accessModes: [ "ReadWriteOnce" ]
  resources:
   requests:
     storage: 300m
```

Kubernetes binds only one PVC to one PV. if there are no volumes for claims, then then claims will remain in the *pending* state. you can also use 'labels' or 'SelectLabels' to defined which volumes to be used for 'claims'
These can be described based on parameters like
- Sufficient capacity
- Access Modes
- Volume Modes
- Storage Class
- Selector

There are different accessModes that can be mounted.
- ReadWriteOnce -- the volume can be mounted as read-write by a single node
- ReadOnlyMany -- the volume can be mounted read-only by many nodes
- ReadWriteMany -- the volume can be mounted as read-write by many nodes

In above example, though you might have an PV with 1G, if the claim is 300M it would select PV with 1GB. though if there are other claims that exists since it can't find the volumes it will be still pending.

If the claims are deleted, we could set parameter in the PV to do these
- Retain ( default ) - though claims are deleted, this will retain the volumes
- Delete - claims are deleted, volumes are deleted
- Recycle - volumes are scrubbed and can be re-used for claims

## Storage Class

We created Persistent Volume but before this if we are taking a volume from Cloud providers like GCP, AWS, Azure. We need to first create disk.

### Static Provisioning
We need to create manually each time when we define in the Pod definition file. that's called Static Provisioning.

### Dynamic Provisioning
No we have a Storage Class, So we no longer to define Persistent Volume. It will create automatically when a Storage Class is created. It's called Dynamic Provisioning

```
sc-definition.yaml

apiVersion: storage.k8s.io/v1
kind: StorageClass
metadata:
  name: slow
provisioner: kubernetes.io/aws-ebs
parameters:
  type: io1
  iopsPerGB: "10"
  fsType: ext4
```

```
kubectl create -f sc-definition.yaml
kubectl get sc
```

```
pvc-definition.yaml

kind: PersistentVolumeClaim
apiVersion: v1
metadata:
  name: myclaim
spec:
  accessModes: [ "ReadWriteOnce" ]
  storageClassName: aws-ebs      
  resources:
   requests:
     storage: 500Mi
```

```
pod-definition.yaml

apiVersion: v1
kind: Pod
metadata:
  name: mypod
spec:
  containers:
    - name: frontend
      image: nginx
      volumeMounts:
      - mountPath: "/var/www/html"
        name: web
  volumes:
    - name: web
      persistentVolumeClaim:
        claimName: myclaim
```
